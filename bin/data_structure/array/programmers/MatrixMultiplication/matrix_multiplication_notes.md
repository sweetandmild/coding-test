
# Matrix Multiplication - Java Implementation and Optimization Notes

## ✅ 기본 행렬 곱셈 구현

```java
public class MatrixMultiplication {

    public int[][] solution(int[][] arr1, int[][] arr2){
        int[][] answer = new int[arr1.length][arr2[0].length];

        for(int i=0; i<arr1.length; i++){
            for(int j=0; j<arr2[0].length; j++){
                for(int k=0; k<arr1[0].length; k++){
                    answer[i][j] += arr1[i][k] * arr2[k][j];
                }
            }
        }

        return answer;
    }
}
```

## ✅ 피드백 요약

### 👍 좋은 점
- 전통적인 행렬 곱셈 로직 정확히 구현
- 코드 간결하고 가독성 좋음
- 결과 배열 크기 정확

### ✏️ 개선 포인트
1. **입력 유효성 검사**
2. **메서드/클래스 명 개선** (`multiply`, `MatrixCalculator` 등)
3. **변수명 개선** (`arr1` → `matrixA`, `answer` → `result`)
4. **희소 행렬이나 병렬 처리 시 최적화 가능성 존재**

---

## 🚀 Strassen 알고리즘 개념 요약

Strassen 알고리즘은 행렬 곱셈의 성능을 높이기 위한 분할 정복 기반의 알고리즘으로, 전통적인 O(n³) 시간 복잡도보다 빠른 약 O(n^{2.81}) 성능을 가집니다.

### 💡 기본 아이디어
- 행렬을 4개의 블록으로 나눈 후, 기존 8회의 곱셈 대신 7개의 곱셈만으로 계산함

두 행렬 A, B를 다음과 같이 분할:
```
A = | A11 A12 |    B = | B11 B12 |
    | A21 A22 |        | B21 B22 |
```

7개의 중간 행렬 계산:
```
M1 = (A11 + A22)(B11 + B22)
M2 = (A21 + A22)B11
M3 = A11(B12 - B22)
M4 = A22(B21 - B11)
M5 = (A11 + A12)B22
M6 = (A21 - A11)(B11 + B12)
M7 = (A12 - A22)(B21 + B22)
```

최종 결과 행렬 C는 다음과 같이 조합:
```
C11 = M1 + M4 - M5 + M7
C12 = M3 + M5
C21 = M2 + M4
C22 = M1 - M2 + M3 + M6
```

### ⚠️ 주의 사항
- 입력 크기는 보통 2의 거듭제곱이어야 함 (padding 필요할 수 있음)
- 덧셈/뺄셈 연산은 증가하므로 작은 행렬에서는 오히려 느릴 수 있음
- 부동소수점 오차가 커질 수 있음

### 🧠 결론
Strassen 알고리즘은 대규모 행렬 연산에서 성능 이점이 있으며, 고성능 계산이 필요한 과학/그래픽/딥러닝 분야 등에서 활용됩니다.

---

## 📚 Java 행렬 곱셈 라이브러리

| 라이브러리             | 특징                               |
|------------------------|------------------------------------|
| Apache Commons Math    | 범용 수치 계산, 선형대수 지원      |
| EJML                   | 고성능 수치 계산, 빠름             |
| JAMA                   | 가벼움, 학습용으로 적합             |
| ND4J                   | 딥러닝/Numpy 스타일, 고성능 계산용 |

✅ JAMA는 표준 라이브러리가 아님 → 수동 추가 or Maven 필요

---

## ⚙️ 루프 순서에 따른 캐시 적중률 실험

### 캐시 적중률이란?
- CPU가 자주 사용하는 데이터를 가까운 메모리(cache)에 저장해 빠르게 접근하는 기술
- 행렬 접근 시 **인접한 메모리 접근**이 캐시 적중률에 영향

### 실험 루프 구조 비교

| 루프 구조 | 메모리 접근 특징         | 성능 경향 |
|-----------|--------------------------|------------|
| i-j-k     | 행 우선 순회 안됨 (느림) | 보통 느림   |
| i-k-j     | 연속된 메모리 접근 (빠름) | 보통 빠름   |

### 실험 코드 예시 (SIZE = 1000)
```java
// multiply_ijk
for (int i = 0; i < SIZE; i++)
    for (int j = 0; j < SIZE; j++)
        for (int k = 0; k < SIZE; k++)
            result[i][j] += A[i][k] * B[k][j];

// multiply_ikj
for (int i = 0; i < SIZE; i++)
    for (int k = 0; k < SIZE; k++)
        for (int j = 0; j < SIZE; j++)
            result[i][j] += A[i][k] * B[k][j];
```

### 성능 실험 결과 예시

환경에 따라 다르지만, 예시 결과는 다음과 같음:

| 루프 구조 | 실행 시간 예시 (ms) |
|-----------|-------------------|
| i-j-k     | 약 3200 ms         |
| i-k-j     | 약 2100 ms         |

→ 일반적으로 `i-k-j` 순서가 캐시 효율로 인해 더 빠름

### 결론
- 현재 구조는 직관적이고 안정적이지만, **성능 최적화 시 i-k-j 순서가 더 유리**
- 캐시 친화적인 순서 선택이 실행 속도에 영향을 미칠 수 있음

---

## ✅ 결론 정리

- 현재 구조는 정석적이고 작은 입력에는 충분히 효율적
- 성능 최적화가 필요할 때는 **루프 순서, 희소 행렬 처리, 병렬화** 등 고려 가능
- 라이브러리나 고급 알고리즘은 필요할 때 도입

---

_Made with help from Mild 🧠_
